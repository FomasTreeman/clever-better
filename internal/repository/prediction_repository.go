package repository

import (
	"context"
	"fmt"
	"time"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5"
	"github.com/yourusername/clever-better/internal/database"
	"github.com/yourusername/clever-better/internal/models"
)

// PostgresPredictionRepository implements PredictionRepository for PostgreSQL
type PostgresPredictionRepository struct {
	db *database.DB
}

// NewPostgresPredictionRepository creates a new prediction repository
func NewPostgresPredictionRepository(db *database.DB) PredictionRepository {
	return &PostgresPredictionRepository{db: db}
}

// Insert inserts a single prediction
func (p *PostgresPredictionRepository) Insert(ctx context.Context, prediction *models.Prediction) error {
	query := `
		INSERT INTO predictions (id, race_id, runner_id, model_id, probability, confidence, features, predicted_at)
		VALUES ($1, $2, $3, $4, $5, $6, $7, $8)
	`

	_, err := p.db.GetPool().Exec(ctx, query,
		prediction.ID, prediction.RaceID, prediction.RunnerID, prediction.ModelID,
		prediction.Probability, prediction.Confidence, prediction.Features, prediction.PredictedAt,
	)
	if err != nil {
		return fmt.Errorf("failed to insert prediction: %w", err)
	}

	return nil
}

// InsertBatch inserts multiple predictions using high-performance batch insert
func (p *PostgresPredictionRepository) InsertBatch(ctx context.Context, predictions []*models.Prediction) error {
	if len(predictions) == 0 {
		return nil
	}

	// Use COPY for high-performance bulk insert
	columns := []string{"id", "race_id", "runner_id", "model_id", "probability", "confidence", "features", "predicted_at"}

	copyFromSource := make([][]interface{}, len(predictions))
	for i, pred := range predictions {
		copyFromSource[i] = []interface{}{
			pred.ID, pred.RaceID, pred.RunnerID, pred.ModelID,
			pred.Probability, pred.Confidence, pred.Features, pred.PredictedAt,
		}
	}

	count, err := p.db.GetPool().CopyFrom(ctx, "predictions", columns, pgx.CopyFromRows(copyFromSource))
	if err != nil {
		return fmt.Errorf("failed to batch insert predictions: %w", err)
	}

	if count != int64(len(predictions)) {
		return fmt.Errorf("inserted %d rows, expected %d", count, len(predictions))
	}

	return nil
}

// GetByRaceID retrieves all predictions for a specific race
func (p *PostgresPredictionRepository) GetByRaceID(ctx context.Context, raceID uuid.UUID) ([]*models.Prediction, error) {
	query := `
		SELECT id, race_id, runner_id, model_id, probability, confidence, features, predicted_at
		FROM predictions
		WHERE race_id = $1
		ORDER BY predicted_at DESC
	`

	rows, err := p.db.GetPool().Query(ctx, query, raceID)
	if err != nil {
		return nil, fmt.Errorf("failed to query predictions by race: %w", err)
	}
	defer rows.Close()

	var predictions []*models.Prediction
	for rows.Next() {
		prediction := &models.Prediction{}
		err := rows.Scan(
			&prediction.ID, &prediction.RaceID, &prediction.RunnerID, &prediction.ModelID,
			&prediction.Probability, &prediction.Confidence, &prediction.Features, &prediction.PredictedAt,
		)
		if err != nil {
			return nil, fmt.Errorf("failed to scan prediction: %w", err)
		}
		predictions = append(predictions, prediction)
	}

	return predictions, rows.Err()
}

// GetByModelID retrieves predictions generated by a specific model within a time range
func (p *PostgresPredictionRepository) GetByModelID(ctx context.Context, modelID uuid.UUID, start, end time.Time) ([]*models.Prediction, error) {
	query := `
		SELECT id, race_id, runner_id, model_id, probability, confidence, features, predicted_at
		FROM predictions
		WHERE model_id = $1 AND predicted_at >= $2 AND predicted_at <= $3
		ORDER BY predicted_at DESC
	`

	rows, err := p.db.GetPool().Query(ctx, query, modelID, start, end)
	if err != nil {
		return nil, fmt.Errorf("failed to query predictions by model: %w", err)
	}
	defer rows.Close()

	var predictions []*models.Prediction
	for rows.Next() {
		prediction := &models.Prediction{}
		err := rows.Scan(
			&prediction.ID, &prediction.RaceID, &prediction.RunnerID, &prediction.ModelID,
			&prediction.Probability, &prediction.Confidence, &prediction.Features, &prediction.PredictedAt,
		)
		if err != nil {
			return nil, fmt.Errorf("failed to scan prediction: %w", err)
		}
		predictions = append(predictions, prediction)
	}

	return predictions, rows.Err()
}
